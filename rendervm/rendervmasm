#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long;
use Data::Dumper;
my $opts = {};
GetOptions(
    $opts,
    'input=s',
    'output=s',
    'carray',
    'cenum',
    'cswitch',
    'copcode2str',
);

my %INS_ARG_LENGTH = (
    HALT                => [0x00, []],
    YIELD               => [0x01, []],
    RESET               => [0x02, []],
    CALL                => [0x03, [2]],
    RETURN              => [0x04, []],
    JUMP                => [0x05, [2]],

    UINT8_PUSH          => [0x10, [1]],
    UINT8_POP           => [0x11, []],
    UINT8_DUP           => [0x12, [2]],
    UINT8_SWAP          => [0x13, []],
    UINT8_STORE         => [0x14, [2]],
    UINT8_STORE_UINT16  => [0x15, []],
    UINT8_LOAD          => [0x16, [2]],
    UINT8_LOAD_UINT16   => [0x17, []],
    UINT8_MOVE_UINT8    => [0x18, []],
    UINT8_COPY_UINT8    => [0x19, [2]],
    UINT8_JUMP_EMPTY    => [0x1a, [2]],
    UINT8_JUMP_ZERO     => [0x1b, [2]],
    UINT8_JUMP_NZERO    => [0x1c, [2]],
    UINT8_ADD           => [0x1d, []],
    UINT8_SUBTRACT      => [0x1e, []],
    UINT8_MULTIPLY      => [0x1f, []],
    UINT8_DIVIDE_FLOAT  => [0x20, []],
    UINT8_EQ            => [0x21, []],

    UINT16_PUSH         => [0x30, [2]],
    UINT16_POP          => [0x31, []],
    UINT16_DUP          => [0x32, [2]],
    UINT16_SWAP         => [0x33, []],
    UINT16_STORE        => [0x34, [2]],
    UINT16_STORE_UINT16 => [0x35, []],
    UINT16_LOAD         => [0x36, [2]],
    UINT16_LOAD_UINT16  => [0x37, []],
    UINT16_MOVE_UINT8   => [0x38, []],
    UINT16_COPY_UINT8   => [0x39, [2]],
    UINT16_JUMP_EMPTY   => [0x3a, [2]],
    UINT16_JUMP_ZERO    => [0x3b, [2]],
    UINT16_JUMP_NZERO   => [0x3c, [2]],
    UINT16_ADD          => [0x3d, []],
    UINT16_SUBTRACT     => [0x3e, []],
    UINT16_MULTIPLY     => [0x3f, []],
    UINT16_DIVIDE_FLOAT => [0x40, []],
    UINT16_EQ           => [0x41, []],

    UINT32_PUSH         => [0x50, [4]],
    UINT32_POP          => [0x51, []],
    UINT32_DUP          => [0x52, [2]],
    UINT32_SWAP         => [0x53, []],
    UINT32_STORE        => [0x54, [2]],
    UINT32_STORE_UINT16 => [0x55, []],
    UINT32_LOAD         => [0x56, [2]],
    UINT32_LOAD_UINT16  => [0x57, []],
    UINT32_MOVE_UINT8   => [0x58, []],
    UINT32_COPY_UINT8   => [0x59, [2]],
    UINT32_JUMP_EMPTY   => [0x5a, [2]],
    UINT32_JUMP_ZERO    => [0x5b, [2]],
    UINT32_JUMP_NZERO   => [0x5c, [2]],
    UINT32_ADD          => [0x5d, []],
    UINT32_SUBTRACT     => [0x5e, []],
    UINT32_MULTIPLY     => [0x5f, []],
    UINT32_DIVIDE_FLOAT => [0x60, []],
    UINT32_EQ           => [0x61, []],

    FLOAT_PUSH          => [0x70, [4]],
    FLOAT_POP           => [0x71, []],
    FLOAT_DUP           => [0x72, [2]],
    FLOAT_SWAP          => [0x73, []],
    FLOAT_STORE         => [0x74, [2]],
    FLOAT_STORE_UINT16  => [0x75, []],
    FLOAT_LOAD          => [0x76, [2]],
    FLOAT_LOAD_UINT16   => [0x77, []],
    FLOAT_MOVE_UINT8    => [0x78, []],
    FLOAT_COPY_UINT8    => [0x79, [2]],
    FLOAT_JUMP_EMPTY    => [0x7a, [2]],
    FLOAT_JUMP_ZERO     => [0x7b, [2]],
    FLOAT_JUMP_NZERO    => [0x7c, [2]],
    FLOAT_ADD           => [0x7d, []],
    FLOAT_SUBTRACT      => [0x7e, []],
    FLOAT_MULTIPLY      => [0x7f, []],
    FLOAT_DIVIDE_FLOAT  => [0x80, []],
    FLOAT_EQ            => [0x81, []],
);

exit main($opts);

sub sorted_keys {
    return sort {$INS_ARG_LENGTH{$a}->[0] <=> $INS_ARG_LENGTH{$b}->[0]} keys %INS_ARG_LENGTH;
}

sub print_copcode2str {
    my @array;
    for my $ins (sorted_keys()) {
        my $idx = $INS_ARG_LENGTH{$ins}->[0];
        $array[$idx] = $ins;
    }

    print "const char *opcode2str[] = {\n";
    for my $ins (@array) {
        if (defined $ins) {
            print "    \"$ins\",\n";
        }
        else {
            print "    \"[unused]\",\n";
        }
    }
    print "    \"[unused]\"\n";
    print "};\n";
}

sub print_cenum {
    print "typedef enum rendervm_opcode {\n";
    for my $ins (sorted_keys()) {
        my $opcode = $INS_ARG_LENGTH{$ins}->[0];
        printf("    VM_$ins = 0x%02x,\n", $opcode);
    }
    print "    VM__INSEND = 0xff\n";
    print "} rendervm_opcode_t;\n";
}

sub print_cswitch {
    print "    switch (opcode) {\n";
    for my $ins (sorted_keys()) {
        print "        case $ins:\n";
        print "            printf(\"$ins: UNIMPLEMENTED\");\n";
        print "            vm->running = 0;\n";
        print "            break;\n";
    }
    print "        default:\n";
    print "            break;\n";
    print "    }\n";
}

sub print_carray {
    my (@binary) = @_;

    my $len = scalar(@binary);
    print "    uint8_t program[$len] = {\n";
    print "        ";
    my $c = 1;
    while (scalar(@binary)) {
        my $int = shift @binary;
        printf("0x%02x", $int);
        if ($c != $len) {
            print ",";
        }
        else {
            print "\n";
        }
        if (!($c % 8)) {
            print "\n        ";
        }
        else {
            print " ";
        }
        $c++;
    }
    print "   };\n";
}

sub write_binary {
    my ($file, @binary) = @_;
    my $bin = pack("C*", @binary);
    open(my $ofh, '>:raw', $file) || die "$!";
    print $ofh $bin;
    close($ofh);
}

sub _expand_constant {
    my ($val, $len) = @_;

    my @codes;
    for (my $i = 0; $i < $len; $i++) {
        push @codes, $val & 255;
        $val = $val >> 8;
    }

    return @codes;
}

sub _convert_to_dec {
    my ($state, $something) = @_;
    if ($something =~ /^0x[0-9a-f]+$/) {
        return hex($something);
    }
    if ($something =~ /^[0-9]+$/) {
        return $something;
    }
    die sprintf(
        "Invalid hex or decimal value: '%s' at '%s' line %d",
        $something,
        $state->{current_file},
        $state->{files}->{$state->{current_file}}->{line_count}
    );
}

sub generate_addresses {
    my ($state) = @_;
    my $addr = 0;

    # Generate addr from all the code items
    for my $code (@{$state->{prg}}) {
        $code->{addr} = $addr;
        $addr++;
        for my $arg (@{$code->{args}}) {
            $addr += $arg->{len};
        }
    }

    # Convert all the label array indexes into absolute addresses
    for my $label (keys %{$state->{markers}}) {
        my $idx = $state->{markers}->{$label};
        my $code = $state->{prg}->[$idx];
        my $label_addr = $code->{addr};
        $state->{markers}->{$label} = $label_addr;
    }

    # Resolve markers to addresses
    for my $code (@{$state->{prg}}) {
        for my $arg (@{$code->{args}}) {
            my $val = $arg->{val};
            my $len = $arg->{len};
            if (ref($val)) {
                if (exists $state->{markers}->{$val->{label}}) {
                    $arg->{val} = $state->{markers}->{$val->{label}};
                }
                else {
                    die sprintf(
                        "Unable to resolve label: '%s' at '%s' line %d",
                        $val->{label},
                        $val->{current_file},
                        $val->{line_count},
                    );
                }
            }
        }
    }
}

sub generate_binary {
    my ($state) = @_;

    my @binary;

    for my $code (@{$state->{prg}}) {
        my $addr = $code->{addr};
        $binary[$addr] = $code->{opcode};
        for my $arg (@{$code->{args}}) {
            my @codes = _expand_constant($arg->{val}, $arg->{len});
            if (scalar(@codes) != $arg->{len}) {
                die "Assembler internal error";
            }
            for (my $i = 0; $i < $arg->{len}; $i++) {
                $addr++;
                $binary[$addr] = $codes[$i];
            }
        }
    }

    return @binary;
}

sub decode_instruction {
    my ($state, $ins, @args) = @_;
    my $ucins = uc($ins);
    if (!exists $INS_ARG_LENGTH{$ucins}) {
        die sprintf(
            "Invalid instruction: '%s' at '%s' line %d",
            $ins,
            $state->{current_file},
            $state->{files}->{$state->{current_file}}->{line_count}
        );
    }

    my ($opcode, $arglens) = @{$INS_ARG_LENGTH{$ucins}};
    my $nr_args = scalar(@{$arglens});

    my $code = {
        opcode => $opcode,
        ucins  => $ucins,
        args   => [],
    };

    for (my $i = 0; $i < $nr_args; $i++) {
        my $arglen = $arglens->[$i];
        my $arg = $args[$i];
        my $val;
        if (exists $state->{defs}->{$arg}) {
            push @{$code->{args}}, {
                val => $state->{defs}->{$arg},
                len => $arglen,
            };
        }
        elsif (exists $state->{markers}->{$arg}) {
            push @{$code->{args}}, {
                val => {
                    label        => $arg,
                    current_file => $state->{current_file},
                    line_count   => $state->{files}->{$state->{current_file}}->{line_count},
                },
                len => $arglen,
            };
        }
        elsif ($arg =~ /^0x[0-9a-f]+$/) {
            push @{$code->{args}}, {
                val => _convert_to_dec($arg),
                len => $arglen,
            };
        }
        elsif ($arg =~ /^[0-9]+$/) {
            push @{$code->{args}}, {
                val => $arg,
                len => $arglen,
            };
        }
        else {
            push @{$code->{args}}, {
                val => {
                    label        => $arg,
                    current_file => $state->{current_file},
                    line_count   => $state->{files}->{$state->{current_file}}->{line_count},
                },
                len => $arglen,
            };
        }
    }

    return $code;
}

sub compile_instruction {
    my ($state, $ins, @args) = @_;
    my $code = decode_instruction($state, $ins, @args);
    push @{$state->{prg}}, $code;
}

sub compile_line {
    my ($state, $line) = @_;

    if ($line =~ /^var\s+([A-Za-z0-9\_]+)\s+([0-9a-z]+)/) {
        $state->{defs}->{$1} = _convert_to_dec($state, $2);
        return;
    }

    if ($line =~ /^([a-zA-Z\_]+):/) {
        $state->{markers}->{$1} = scalar(@{$state->{prg}}); # then next index
        return;
    }

    if ($line =~ /^\s+([^;]+)/) {
        my $command = $1;
        $command =~ s/\s+$//;
        if ($command =~ /^([a-z0-9_]+)\s*(.*)$/) {
            my ($ins, $rest) = ($1, $2);
            my @args = split(/\s+/, $rest);
            compile_instruction($state, $ins, @args);
        }
    }
}

sub load_file {
    my ($filename) = @_;
    my $program = "";
    open(my $fh, '<', $filename) || die "unable to open file $filename: $!\n";
    while (my $line = <$fh>) {
        $program .= $line;
    }
    close($fh);
    return $program;
}

sub compile_file {
    my ($state, $filename) = @_;
    my $program = load_file($filename);
    my @lines = split(/\n/, $program);
    $state->{current_file} = $filename;
    $state->{files}->{$state->{current_file}}->{line_count} = 1;
    LINE: for my $line (@lines) {
        chomp $line;
        unless ($line) {
            $state->{files}->{$state->{current_file}}->{line_count}++;
            next LINE;
        }
        compile_line($state, $line);
        $state->{files}->{$state->{current_file}}->{line_count}++;
    }
}

sub compile {
    my ($opts) = @_;

    my $state = {
        addr => 0,
        prg => [],
    };

    compile_file($state, $opts->{input});
    generate_addresses($state);

    my @binary = generate_binary($state);

    return @binary;
}

sub main {
    my ($opts) = @_;

    if ($opts->{carray}) {
        my @binary = compile($opts);
        print_carray(@binary);
    }
    elsif ($opts->{output}) {
        my @binary = compile($opts);
        write_binary($opts->{output}, @binary);
    }
    elsif ($opts->{cenum}) {
        print_cenum();
    }
    elsif ($opts->{cswitch}) {
        print_cswitch();
    }
    elsif ($opts->{copcode2str}) {
        print_copcode2str();
    }
    else {
        die "No --output=<bin> or --carray options\n";
    }
}
